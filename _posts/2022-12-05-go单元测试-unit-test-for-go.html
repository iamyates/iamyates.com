<p data-pid="jNlK-4Ou">单元测试，一个不断被强调，但又不断被忽略的话题，从一名码农成长为一名优秀的工程师，单元测试，是必不可少的技能。单元测试是在所有测试环节中最先完成的，在我们写代码的过程中就需要写单元测试，也可能在未写代码前先写测试。个人认为编码能力，代码评审和单元测试是一个研发同学必备的三大重要技能。</p>

<h2>Go常用测试框架</h2><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>框架名称</th><th>特征</th><th>优点</th><th>缺点</th><th>备注</th></tr><tr><td>Testing</td><td>table-driver测试<br>支持基准测试</td><td>Go原生<br>简单易用</td><td>不支持mock<br>不支持assert</td><td>testing包文档：<br><a href="https://link.aa.com/?target=http%3A//cngolib.com/testing.html" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://</span><span class="visible">cngolib.com/testing.htm</span><span class="invisible">l</span><span class="ellipsis"></span></a></td></tr><tr><td>Testify</td><td>table-driver测试<br><br>支持mock<br>支持assert<br><br>兼容go test</td><td>支持assert，功能强大易用<br>支持mock<br>兼容go test<br>社区活跃度高</td><td>mock能力较弱</td><td>官方文档：<a href="https://link.xx.com/?target=https%3A//pkg.go.dev/github.com/stretchr/testify" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://</span><span class="visible">pkg.go.dev/github.com/s</span><span class="invisible">tretchr/testify</span><span class="ellipsis"></span></a></td></tr><tr><td>GoConvey</td><td>支持assert<br><br>支持web界面<br>支持colorized输出<br>支持测试用例层级嵌套<br>兼容go test</td><td>支持web界面<br>支持colorized输出<br>支持测试用例层级嵌套</td><td>不支持mock<br>社区不太活跃</td><td>项目地址：<br><a href="https://link.xx.com/?target=https%3A//github.com/smartystreets/goconvey" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://</span><span class="visible">github.com/smartystreet</span><span class="invisible">s/goconvey</span><span class="ellipsis"></span></a><br><br>安装：go get <a href="https://link.xx.com/?target=http%3A//github.com/smartystreets/goconvey" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://</span><span class="visible">github.com/smartystreet</span><span class="invisible">s/goconvey</span><span class="ellipsis"></span></a></td></tr><tr><td>Ginkgo</td><td>支持基准测试<br>支持并发测试<br>兼容go test</td><td>支持并发测试</td><td></td><td>手册：<a href="https://link.xx.com/?target=https%3A//www.ginkgo.wiki/" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://www.</span><span class="visible">ginkgo.wiki/</span><span class="invisible"></span></a><br>安装：<br>go get <a href="https://link.xx.com/?target=http%3A//github.com/onsi/ginkgo/ginkgo" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://</span><span class="visible">github.com/onsi/ginkgo/</span><span class="invisible">ginkgo</span><span class="ellipsis"></span></a></td></tr></tbody></table><h2>Mock</h2><p data-pid="8nPRL5Ie">在写单测过程中，常会遇到有些不容易构造或者不容易获取的对象，这时候我们要创建一个虚拟的对象以便测试。</p><p data-pid="tWkyPZVg">常用的Mock可以归纳为两类：</p><h3>打桩Stub</h3><p data-pid="JiBPRGz6">代表框架：GoMonkey、monkey、GoStub</p><p data-pid="VLueCrQ1">主要通过打补丁（Patch）的方式替换函数、方法、变量等等</p><div class="highlight"><pre><code class="language-text">	monkey.PatchInstanceMethod(reflect.TypeOf(personService), "GetPersonById", func(_ *PersonServiceImpl, _ string) (*Person, error) {
		return &amp;Person{
			Name: "test_name",
		}, nil
	})</code></pre></div><h3>依赖注入+GoMock</h3><p data-pid="gecMCHft">这种方法要求业务代码必须以“依赖倒置”的方式实现。关于什么是“依赖倒置原则”，参考官方的定义：</p><ol><li data-pid="t36vgR7F">高层模块不应该依赖底层模块，两个都应该依赖抽象。</li><li data-pid="IwzPm-Wy">抽象不应该依赖细节，细节应该依赖抽象。“抽象”是指接口（interface）或者抽象类（abstract class），“细节”指的是实现（struct或者class）。</li></ol><p data-pid="Msy4mFFS">举例来说，比如在业务层我们会定义一些接口，如获取用户信息：</p><div class="highlight"><pre><code class="language-text">type UserStorager interface {
	GetUserInfo(context.Context, *UserParam) (User, error)
}</code></pre></div><p data-pid="xTB1JzPH">对于这些接口使用gomock进行模拟，通过mockgen -source=user.go -destination=user_mock.go 可自动生成接口应的mock实现</p><div class="highlight"><pre><code class="language-text">// Code generated by MockGen. DO NOT EDIT.
// Source: user.go

// Package mock_user is a generated GoMock package.
package mock_user

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	ibasic "icode.baidu.com/baidu/bfe-private-cloud/control-api/api-server/module/ibasic"
)

// MockUserStorager is a mock of UserStorager interface.
type MockUserStorager struct {
	ctrl     *gomock.Controller
	recorder *MockUserStoragerMockRecorder
}

// MockUserStoragerMockRecorder is the mock recorder for MockUserStorager.
type MockUserStoragerMockRecorder struct {
	mock *MockUserStorager
}

// NewMockUserStorager creates a new mock instance.
func NewMockUserStorager(ctrl *gomock.Controller) *MockUserStorager {
	mock := &amp;MockUserStorager{ctrl: ctrl}
	mock.recorder = &amp;MockUserStoragerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserStorager) EXPECT() *MockUserStoragerMockRecorder {
	return m.recorder
}

// GetUserInfo mocks base method.
func (m *MockUserStorager) GetUserInfo(arg0 context.Context, arg1 *ibasic.UserParam) (ibasic.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserInfo", arg0, arg1)
	ret0, _ := ret[0].(ibasic.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserInfo indicates an expected call of GetUserInfo.
func (mr *MockUserStoragerMockRecorder) GetUserInfo(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserInfo", reflect.TypeOf((*MockUserStorager)(nil).GetUserInfo), arg0, arg1)
}
</code></pre></div>
